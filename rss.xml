<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[Kzu's Today I Learned]]></title>
        <description><![CDATA[My daily learning tidbits.]]></description>
        <link>https://til.cazzulino.com/</link>
        <image>
            <url>https://github.com/kzu/kzu.github.io/raw/master/img/kzu.jpg</url>
            <title>Kzu&apos;s Today I Learned</title>
            <link>https://til.cazzulino.com/</link>
        </image>
        <generator>RSS for Node</generator>
        <lastBuildDate>Sat, 30 Jan 2021 01:00:53 GMT</lastBuildDate>
        <atom:link href="https://til.cazzulino.com/rss.xml" rel="self" type="application/rss+xml"/>
        <author><![CDATA[Daniel Cazzulino]]></author>
        <item>
            <title><![CDATA[Today I Learned]]></title>
            <link>https://til.cazzulino.com/</link>
            <guid isPermaLink="true">https://til.cazzulino.com/</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[NuGet]]></title>
            <link>https://til.cazzulino.com/dotnet/nuget/README.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/nuget/README.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Hide contentFiles from your nuget packages]]></title>
            <description><![CDATA[When you package compile items with your package (i.e. .cs), they are visible by default in your consumer's project. That's not always what you want. From a github issue on NuGet, I learned a neat trick to hide all the files in your package, automatically! All you need is to include a .props file in your package build folder (i.e. if your package is named Foo, make sure the file ends up build\Foo.props)]]></description>
            <link>https://til.cazzulino.com/dotnet/nuget/hide-contentfiles-from-your-nuget-packages.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/nuget/hide-contentfiles-from-your-nuget-packages.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Packaging transitive analyzers with NuGet]]></title>
            <description><![CDATA[Consider the scenario of ThisAssembly and its referenced packages: the main package is essentially a meta-package so that anyone wanting to leverage all the codegen in all the ThisAssembly.* packages can reference a single one. By default, NuGet pack will create a package that declares the project reference dependencies like so:]]></description>
            <link>https://til.cazzulino.com/dotnet/nuget/packaging-transitive-analyzers-with-nuget.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/nuget/packaging-transitive-analyzers-with-nuget.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to add search to static nuget feed]]></title>
            <description><![CDATA[I have been using static serverless nuget feeds for a while now. Sleet is totally awesome. One missing piece was search: searching a static feed would just return everything, always. Not anymore!]]></description>
            <link>https://til.cazzulino.com/dotnet/nuget/use-dotnet-vs-to-get-developer-prompt-in-terminal.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/nuget/use-dotnet-vs-to-get-developer-prompt-in-terminal.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Populate RepositoryBranch in CI for NuGet Pack]]></title>
            <description><![CDATA[I learned that RepositoryBranch is the only NuGet Pack-related property not populated already by the .NET SDK+SourceLink. So instead of going for a full-blown (and typically over-blown) solution for build/assembly versioning from Git information (such as GitInfo or GitVersion or the myriad others), you can trivially pass in this value from your CI script with:]]></description>
            <link>https://til.cazzulino.com/dotnet/nuget/populate-repositorybranch-in-ci-for-nuget-pack.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/nuget/populate-repositorybranch-in-ci-for-nuget-pack.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Quickly check C# compiler and language version]]></title>
            <description><![CDATA[Just add #error version anywhere in a C# file and you'll see a tooltip with the information:]]></description>
            <link>https://til.cazzulino.com/dotnet/quickly-check-c-compiler-and-language-version.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/quickly-check-c-compiler-and-language-version.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Disable diagnostic analyzers for entire folder/submodules]]></title>
            <description><![CDATA[When you have submodules in your repository, it's not uncommon for those to be subject to a different quality bar than your main project. You may not even have a say in fixing issues upstream, or conventions may be totally different even.]]></description>
            <link>https://til.cazzulino.com/dotnet/disable-diagnostic-analyzers-for-entire-folder-submodules.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/disable-diagnostic-analyzers-for-entire-folder-submodules.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Persisting output files from source generators]]></title>
            <description><![CDATA[Some time back, I had my own I/O code that based on some MSBuild property would persist my generated source for troubleshooting. This is no longer needed since you can now set]]></description>
            <link>https://til.cazzulino.com/dotnet/persisting-output-files-from-source-generators.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/persisting-output-files-from-source-generators.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Use C# 9 records in non-net5.0 projects]]></title>
            <description><![CDATA[The new C# 9 records syntax is quite nice:]]></description>
            <link>https://til.cazzulino.com/dotnet/use-c-9-records-in-non-net5.0-projects.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/use-c-9-records-in-non-net5.0-projects.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[AsyncLocal never leaks and is safe for CallContext-like state]]></title>
            <description><![CDATA[Sometime ago I wrote on How to migrate CallContext to .NETStandard and .NETCore, and one question mentioned that the values themselves might leak, which actually is not the case, as shown here, due to the "magic" that is AsyncLocal in combination with the transient nature of the ExecutionContext:]]></description>
            <link>https://til.cazzulino.com/dotnet/asynclocal-never-leaks-and-is-safe-for-callcontext-like-state.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/asynclocal-never-leaks-and-is-safe-for-callcontext-like-state.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Using HashCode in .NETFramework]]></title>
            <description><![CDATA[So, I just learned that not even in .net472/net48, you can leverage the cool HashCode type from .NETCore. It is mentioned in docs as available in ".NET Platform Extensions 3.1", which isn't quite clear what it means. After a quick search here and there, I found out the Microsoft.Bcl.HashCode package, which seems to be one such ".NET platform extension" (although the version # doesn't match either :/).]]></description>
            <link>https://til.cazzulino.com/dotnet/using-hashcode-in-.netframework.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/using-hashcode-in-.netframework.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to locate dotnet]]></title>
            <description><![CDATA[I've seen a bunch of DotNetMuxer implementations, but they all look quite similar (if not exactly the same).]]></description>
            <link>https://til.cazzulino.com/dotnet/how-to-locate-dotnet.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/dotnet/how-to-locate-dotnet.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Conditional unit tests]]></title>
            <description><![CDATA[Turns out that there aren't any conditional FactAttribute in xunit, but you can pretty much copy wholesale the extensions created by the ASP.NET Core team from their repo.]]></description>
            <link>https://til.cazzulino.com/testing/conditional-unit-tests.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/testing/conditional-unit-tests.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Skip tagged scenarios in SpecFlow with Xunit]]></title>
            <description><![CDATA[First apply a tag of your choosing to flag scenarios that are still not ready for running:]]></description>
            <link>https://til.cazzulino.com/testing/skip-tagged-scenarios-in-specflow-with-xunit.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/testing/skip-tagged-scenarios-in-specflow-with-xunit.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Modifying the build for every solution in a repository]]></title>
            <description><![CDATA[Just like you can have Directory.Build.props and Directory.Build.targets to customize your projects' build, you can also use Directory.Solution.props and Directory.Solution.targets to customize your solutions (command-line) builds. Just like the original (older?) mecanisms, Visual Studio will not load those customizations either, however.]]></description>
            <link>https://til.cazzulino.com/msbuild/modifying-the-build-for-every-solution-in-a-repository.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/modifying-the-build-for-every-solution-in-a-repository.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Detect CI builds for every CI system]]></title>
            <description><![CDATA[In order to unify the environment variable to detect whether a build is a CI build as simply CI (as is done already in GitHub Actions, Circle CI and GitLab), you just place this bit of MSBuild in every project's Directory.Build.props to make things consistent everywhere:]]></description>
            <link>https://til.cazzulino.com/msbuild/detect-ci-builds-for-every-ci-system.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/detect-ci-builds-for-every-ci-system.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Modify all command-line builds in entire repo]]></title>
            <description><![CDATA[I used to place msbuild.rsp response files alongside solution and project files to avoid repeating -nr:false -v:m -bl (no node reuse, minimal verbosity, binlogs). It was super annoying to have to have it all over the place. While browsing another repo, I just learned that since MSBuild 15.6+, you can now have a Directory.Build.rsp response file that affects every build in every descendent folder. This sounds like a great default one for me:]]></description>
            <link>https://til.cazzulino.com/msbuild/modify-all-command-line-builds-in-entire-repo.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/modify-all-command-line-builds-in-entire-repo.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Write entire XML fragments in MSBuild with XmlPoke]]></title>
            <description><![CDATA[I recently needed to write an entire project file via a targets (weird, I know). I was dreading all the crazy angle brackets escaping as &lt; and &gt; when I decided to check the latest official docs on XmlPoke to refresh the parameters and format. To my surprise, I found this example:]]></description>
            <link>https://til.cazzulino.com/msbuild/write-entire-xml-fragments-in-msbuild-with-xmlpoke.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/write-entire-xml-fragments-in-msbuild-with-xmlpoke.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to select first item in an ItemGroup]]></title>
            <description><![CDATA[I was entirely unaware of this simple trick! Turns out that when you assign a property value to an item metadata, and there are multiple items, all items are iterated and the property is assigned consecutively to each item metadata, leaving you with the last such item metadata as the property value.]]></description>
            <link>https://til.cazzulino.com/msbuild/how-to-select-first-item-in-an-itemgroup.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/how-to-select-first-item-in-an-itemgroup.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to include commit URL in nuget package description]]></title>
            <description><![CDATA[It's quite helpful to include a direct link to the source code that produced a given package version, so your users can quickly see what's included (i.e. they may be tracking a bug fix).]]></description>
            <link>https://til.cazzulino.com/msbuild/how-to-include-commit-url-in-nuget-package-description.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/how-to-include-commit-url-in-nuget-package-description.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to include package reference files in your nuget]]></title>
            <description><![CDATA[This is a particularly common scenario if you're developing MSBuild tasks or Roslyn code analyzers: all the dependencies you use in your task, analyzer or source generator, need to be included in your nuget package too, alongside your project primary output (i.e. under the properanalyzer, tools or buildfolders). A very convenient way (if not comprehensive, since it won't include with transitive dependencies) to do so is by annotating your PackageReference themselves, like:]]></description>
            <link>https://til.cazzulino.com/msbuild/how-to-include-package-reference-files-in-your-nuget-package.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/how-to-include-package-reference-files-in-your-nuget-package.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to build project when content files change]]></title>
            <description><![CDATA[Visual Studio will typically just report the project is up-to-date and doesn't need to be built if you just changed a Content or None item. If you want it to consider those file types to also trigger a build, just add the relevant items as UpToDateCheckInput:]]></description>
            <link>https://til.cazzulino.com/msbuild/how-to-build-project-when-content-files-change.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/msbuild/how-to-build-project-when-content-files-change.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[C# script function apps beyond Azure portal]]></title>
            <description><![CDATA[Creating a C# function app in the Azure portal is incredibly simple and great for playing and learning. I love the simplicity and light-ness that comes from just having a single .csx script file with everything you need for the function. The more "serious" approach with a "proper" C# project, the functions SDK and the corresponding CI/CD setup seems quite the leap, in comparison.]]></description>
            <link>https://til.cazzulino.com/azure/c-script-function-apps-beyond-azure-portal.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/c-script-function-apps-beyond-azure-portal.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Publishing function app from GitHub folder]]></title>
            <description><![CDATA[For very simple functions, I really liked just hacking them in the Azure portal. This is super brittle, however, since changes that break the app can't be undone. Great for learning, not so much once you start depending on those functions.]]></description>
            <link>https://til.cazzulino.com/azure/publishing-function-app-from-github-folder.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/publishing-function-app-from-github-folder.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Exploring Azure Data with Kusto and Dashboards]]></title>
            <description><![CDATA[In order to more effectively learn Kusto (the query language powering Azure analytics, log querying and PowerBI) and data visualization capabilites in Azure, I did the following:]]></description>
            <link>https://til.cazzulino.com/azure/exploring-azure-data-with-kusto-and-dashboards.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/exploring-azure-data-with-kusto-and-dashboards.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Shared secret authorization with Azure SignalR Service]]></title>
            <description><![CDATA[While testing out Azure Functions development and configuration with Azure SignalR Service, I needed a very simple key-based (shared secret) authorization mechanism so that my console-based SignalR client could connect to my Azure SignalR Service-powered hub using a very simple mechanism.]]></description>
            <link>https://til.cazzulino.com/azure/shared-secret-authorization-with-azure-signalr-service.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/shared-secret-authorization-with-azure-signalr-service.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Using Azure File Copy from DevOps yaml pipeline]]></title>
            <description><![CDATA[Oh boy, did I waste time on this one :(. So I had my pipeline pretty naively doing an upload to blob storage:]]></description>
            <link>https://til.cazzulino.com/azure/using-azure-file-copy-from-devops-yaml-pipeline.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/using-azure-file-copy-from-devops-yaml-pipeline.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Code-less redirection with serverless Azure Functions]]></title>
            <description><![CDATA[Say you want to have a nicer URI for something (like an Azure storage blob, a feed or something else). You  likely have a nice short custom domain (i.e. I use kzu.io for things like this), and would like to set up arbitrary (temporary or permanent) redirections. This can trivially be achieved by creating an empty Functions App and leveraging Functions Proxies.]]></description>
            <link>https://til.cazzulino.com/azure/code-less-redirection-with-serverless-azure-functions.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/azure/code-less-redirection-with-serverless-azure-functions.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[How to skip steps or jobs in GitHub Actions for PRs from forks]]></title>
            <description><![CDATA[Encrypted secrets in GitHub actions aren't available for builds from forks, so if your build script includes PRs, like Avatar:]]></description>
            <link>https://til.cazzulino.com/devops-ci-cd/how-to-skip-steps-or-jobs-in-github-actions-for-prs-from-forks.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/devops-ci-cd/how-to-skip-steps-or-jobs-in-github-actions-for-prs-from-forks.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Update version and publish npm from GH]]></title>
            <description><![CDATA[Super proud of this, since it's my first node.js package ever (created brand-new account on https://www.npmjs.com/ and all ðŸ˜), for doing syntax highlighting for dotnetconfig that works in docfx.]]></description>
            <link>https://til.cazzulino.com/devops-ci-cd/update-version-and-publish-npm-from-gh.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/devops-ci-cd/update-version-and-publish-npm-from-gh.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
        <item>
            <title><![CDATA[Push to protected branch from GitHub actions]]></title>
            <description><![CDATA[It turns out that you really can't just git push from your GitHub actions if the repository has branch protection turned on or required checks before merging. Sorta makes sense, but still a PITA.]]></description>
            <link>https://til.cazzulino.com/devops-ci-cd/push-to-protected-branch-from-github-actions.html</link>
            <guid isPermaLink="true">https://til.cazzulino.com/devops-ci-cd/push-to-protected-branch-from-github-actions.html</guid>
            <dc:creator><![CDATA[Daniel Cazzulino]]></dc:creator>
        </item>
    </channel>
</rss>